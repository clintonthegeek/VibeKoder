Simple VibeKoder Development Seed
======

We are creating a non-conversational vibe coding LLM client in Qt and C++.

A conversation, in generic LLM chat, is a linear chain of prompt-response pairs concatenated into huge contexts. We differentiate non-conversational workflow: where each prompt is independent and built fresh each time, without relying on the sequence and history of previous prompts. VibeKoder avoids the conversation metaframe in favor of discrete task-oriented prompt-response cycles with integrated context.

VibeKoder is a prompt stack assembler. The prompt stack is a VibeKoder-specific coined term describing the structured layering, inclusion, and selection of documentation, source code fragments, diffs, and instructions assembled to build the actual prompt string sent to the LLM. This includes hierarchical toggles, filters, and granularity controls—mirroring a “stack” of context layers.

Instead of linear conversation, the development will proceed around the lateral traversal of prompt stack instances, each of which is premised upon a fresh snapshot of the codebase.

## A prompt stack instance.
The user begins by creating a single amalgamated snapshot of the entire codebase, upon which to build a single instance of a prompt stack. This will likely be a single text file, as though generated by the following bash script:

```bash
#!/bin/bash

# Ensure exactly one argument (folder path) is provided
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <folder>"
    exit 1
fi

# Assign folder path and remove any trailing slash
FOLDER="${1%/}"

# Ensure the folder exists
if [ ! -d "$FOLDER" ]; then
    echo "Argument must be a valid directory."
    exit 1
fi

# Print the directory tree.
# The -P flag uses a pattern (here a regex-like alternation using |) to only list:
#   *.h, *.cpp, and CMakeLists.txt files.
# The -I flag excludes any files or directories matching 'build'.
# Note: A trailing slash in a pattern (e.g. 'build/') would match directories.
echo "Directory Tree:"
tree --prune -P '*.h|*.cpp|*.ui|CMakeLists.txt' -I 'build' "$FOLDER"
echo

# Function to print files in Markdown format (recursively, excluding the build folder)
print_files() {
    local pattern="$1"
    # -path "$FOLDER/build" -prune tells find to ignore the build folder
    find "$FOLDER" -path "$FOLDER/build" -prune -o -type f -name "$pattern" -print | sort | while read -r file; do
        # Calculate relative path: remove the base folder plus trailing slash
        rel="${file#$FOLDER/}"
        echo "### \`${rel}\`"
        echo '```cpp'
        cat "$file"
        echo '```'
        echo
    done
}

# Print files in the desired order.
print_files "CMakeLists.txt"
print_files "*.h"
print_files "*.cpp"
print_files "*.ui"

```

In the GUI, the user will see only the markdown headers of each file in the codebase, easily toggled with a checkbox.

Likewise, development docs written in markdown, such as planning docs, vision docs, coding style instructions, etc. are inserted into the stack, and have their headers parsed and put into a tree for selective inclusion.

At the point where the LLM gives its first response to this initial stack, a line is drawn. A conversation-like prompt and response cycle, or turn begins begins. Unlike a continuous chat, this cycle cycle can be collapsed by the user, summarizing or replacing earlier segments or diff elements to keep the working context focused and efficient.

As development proceeds, the user will make changes to the codebase, resulting in `diff`s which might be automatically captured and inserted into the stack, alloowing them to erase individual conversational prompts and responses from the stack.

Likewise, commits to the git repo can collapse progress into a single big diff.

The source documents, early in the stack, are maintained by the user, tracking progress and being updated.

If and when the user decides that the codebase has drifted sufficiently from the intital snapshot at the base of the prompt stack instance, they can make a lateral move toward a fresh prompt-stack, purging all the diffs in the prompt and response cycle and updating the status of the project directly in their development texts, creating a wholly fresh context for development.

At any time, the user can have multiple prompt stacks open, each playing different roles, perhaps even working within different git branches of the same codebase.  The user will be responsible for properly managing the merging and splitting of such branches, however.

## The Project

I would like to create such a tool in Qt and C++. I would like to borrow as much code as possible from the following codebase for a standard chat application, while building, in fact, something entirely new out of its low-level parts. (Notice that this code was made from the bash script above. This very prompt is an example of the sort of prompt stack I want to automatically compile with our app. This recursion is an important implementation detail!)

Directory Tree:
.
├── audio_recorder.cpp
├── audio_recorder.hpp
├── awesome_chatgpt_prompts.cpp
├── awesome_chatgpt_prompts.h
├── ChatPage.qml
├── ChatView.qml
├── CMakeLists.txt
├── core
│   └── Style.qml
├── fileio.cpp
├── fileio.h
├── json_mapper.cpp
├── live.qml
├── main.cpp
├── main.qml
├── openai_message.cpp
├── openai_message.h
├── openai_message_model.cpp
├── openai_message_model.h
├── openai_request.cpp
├── openai_request.hpp
├── qml.qrc
├── RecordButton.qml
├── resources.qrc
├── SettingsPage.qml
├── TopLevel.qml
├── watson_tts_request.cpp
└── watson_tts_request.h

2 directories, 27 files

### `CMakeLists.txt`
```cpp
cmake_minimum_required(VERSION 3.16)

project(Intellicute VERSION 0.1 LANGUAGES CXX)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 6.2 COMPONENTS Core Multimedia Quick Network TextToSpeech REQUIRED)

qt_add_executable(intellicute
    main.cpp
    openai_request.cpp
    openai_message.cpp
    openai_message_model.cpp
    audio_recorder.cpp
    watson_tts_request.cpp
    fileio.cpp
    qml.qrc
    resources.qrc
)

if (ANDROID)
    set(ANDROID_SSL_PATH /home/alexander/bin/android/android_openssl/latest/arm/)
    set_property(TARGET intellicute PROPERTY QT_ANDROID_EXTRA_LIBS
        ${ANDROID_SSL_PATH}/libcrypto_1_1.so
        ${ANDROID_SSL_PATH}/libssl_1_1.so)
    set_property(TARGET intellicute PROPERTY QT_ANDROID_PACKAGE_SOURCE_DIR
        ${PROJECT_SOURCE_DIR}/android)
endif()

qt_add_qml_module(intellicute
    URI Intellicute
    VERSION 1.0
)


set_target_properties(intellicute PROPERTIES
    MACOSX_BUNDLE_GUI_IDENTIFIER intellicute.machinekoder.com
    MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
    MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
    MACOSX_BUNDLE TRUE
    WIN32_EXECUTABLE TRUE
)

target_link_libraries(intellicute
    PRIVATE Qt6::Core Qt6::Multimedia Qt6::Quick Qt6::Network Qt6::TextToSpeech)

install(TARGETS intellicute
    BUNDLE DESTINATION .
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
```

### `awesome_chatgpt_prompts.h`
```cpp
#pragma once

#include <QObject>

class AwesomeChatGptPrompts: public QObject
{
public:
    explicit AwesomeChatGptPrompts(QObject *parent = nullptr);
    ~AwesomeChatGptPrompts();

private:

};
```

### `fileio.h`
```cpp
#pragma once

#include <QObject>
#include <QtQml>

class FileIO : public QObject
{
    Q_OBJECT
    QML_ELEMENT

    Q_PROPERTY(QUrl filePath READ filePath WRITE setFilePath NOTIFY filePathChanged)
    Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_PROPERTY(bool error READ hasError NOTIFY errorChanged)

public:
    explicit FileIO(QObject *parent = nullptr);

public slots:
    bool read();
    bool write();

    QUrl filePath() const;
    void setFilePath(const QUrl &filePath);

    QString text() const;
    void setText(const QString &text);

    QString errorString() const;

    bool hasError() const;

signals:
    void filePathChanged();
    void textChanged();
    void errorStringChanged();
    void errorChanged();

private:
    QUrl m_filePath;
    QString m_text;
    QString m_errorString;
    bool m_error;
};
```

### `openai_message.h`
```cpp
#pragma once

#include <QObject>
#include <QtQml>

class OpenAIMessage: public QObject
{
    Q_OBJECT
    QML_ELEMENT
    QML_UNCREATABLE("OpenAIMessage is not creatable")

    Q_PROPERTY(QString content READ content WRITE setContent NOTIFY contentChanged)
    Q_PROPERTY(Role role READ role WRITE setRole NOTIFY roleChanged)

    Q_ENUMS(Role)

public:
    enum class Role {
        System,
        User,
        Assistant
    };

    explicit OpenAIMessage(QObject *parent = nullptr);
    explicit OpenAIMessage(const QString& content, Role role, QObject *parent = nullptr);
    ~OpenAIMessage();

    inline static QString roleToString(Role role)
    {
        switch (role) {
            case Role::System:
                return "system";
            case Role::User:
                return "user";
            case Role::Assistant:
                return "assistant";
            default:
                return "unknown";
        }
    }

    inline static Role roleFromString(const QString& role)
    {
        if (role == "system") {
            return Role::System;
        } else if (role == "user") {
            return Role::User;
        } else if (role == "assistant") {
            return Role::Assistant;
        } else {
            return Role::System;
        }
    }


public slots:
    QString content() const;
    void setContent(const QString& content);

    Role role() const;
    void setRole(Role role);

signals:
    void contentChanged();
    void roleChanged();

private:
    QString m_content;
    Role m_role;

};
```

### `openai_message_model.h`
```cpp
#pragma once

#include <QObject>
#include <QAbstractListModel>
#include <QtQml>

#include "openai_message.h"

class OpenAIMessageModel : public QAbstractListModel
{
    Q_OBJECT
    QML_ELEMENT
    Q_PROPERTY(QList<OpenAIMessage*> messages READ messages WRITE setMessages NOTIFY messagesChanged)
    Q_PROPERTY(QString jsonString READ jsonString WRITE setJsonString NOTIFY jsonStringChanged)

public:
    enum Role {
        MessageRole = Qt::UserRole + 1,
        RoleRole
    };

    explicit OpenAIMessageModel(QObject *parent = nullptr);
    ~OpenAIMessageModel();

    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QHash<int, QByteArray> roleNames() const override;

    QList<OpenAIMessage *> messages() const;
    void setMessages(const QList<OpenAIMessage *> &newMessages);

    QString jsonString() const;
    void setJsonString(const QString &newJsonString);

public slots:
    void addMessage(OpenAIMessage::Role role, const QString& content);
    void addMessage(OpenAIMessage *message);
    void removeMessage(OpenAIMessage *message);
    void clearMessages();

signals:
    void messagesChanged();
    void jsonStringChanged();

private:
    QList<OpenAIMessage*> m_messages;
    QString m_jsonString;

    QList<OpenAIMessage*> messagesFromJson(const QString &jsonString) const;
    QString jsonFromMessages(const QList<OpenAIMessage*> &messages) const;
};
```

### `watson_tts_request.h`
```cpp
#pragma once

#include <QObject>
#include <QUrl>
#include <QNetworkAccessManager>
#include <QtQml>

class WatsonTTSRequest: public QObject
{
    Q_OBJECT
    QML_ELEMENT

    Q_PROPERTY(QString accessToken READ accessToken WRITE setAccessToken NOTIFY accessTokenChanged)
    Q_PROPERTY(QString voice READ voice WRITE setVoice NOTIFY voiceChanged)
    Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged)
    Q_PROPERTY(QUrl apiURL READ apiURL WRITE setApiURL NOTIFY apiURLChanged)
    Q_PROPERTY(QString filePath READ filePath NOTIFY filePathChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_PROPERTY(RequestStatus status READ status NOTIFY statusChanged)

    Q_ENUMS(RequestStatus)

public:
    explicit WatsonTTSRequest(QObject *parent = nullptr);
    ~WatsonTTSRequest();

    enum class RequestStatus {
        Idle,
        InProgress,
        Error,
        Success
    };

public slots:
    QString accessToken() const;
    void setAccessToken(const QString& accessToken);

    QString voice() const;
    void setVoice(const QString& voice);

    QString text() const;
    void setText(const QString& text);

    QUrl apiURL() const;
    void setApiURL(const QUrl& apiURL);

    QString filePath() const;
    QString errorString() const;
    RequestStatus status() const;

    void execute();

signals:
    // Signal emitted when the request is finished successfully
    void requestFinished();

    // Signal emitted when the request encounters an error
    void requestError(const QString& errorString);

    void accessTokenChanged();
    void voiceChanged();
    void textChanged();
    void apiURLChanged();
    void filePathChanged();
    void errorStringChanged();
    void statusChanged();

private:
    QNetworkAccessManager *m_networkAccessManager;
    QString m_accessToken;
    QString m_voice;
    QString m_text;
    QUrl m_apiURL;
    QString m_filePath;
    QString m_errorString;
    RequestStatus m_status;

    void sendRequest();
};
```

### `audio_recorder.cpp`
```cpp
#include "audio_recorder.hpp"

#include <QStandardPaths>
#include <QAudioInput>
#include <QImageCapture>
#include <QAudioDevice>
#include <QVariant>
#include <QMediaFormat>
#include <QUrl>

AudioRecorder::AudioRecorder(QObject *parent)
    : QObject(parent)
    , m_filePath("")
    , m_captureSession()
    , m_audioRecorder(nullptr)
{
    m_audioRecorder = new QMediaRecorder(this);
    m_captureSession.setRecorder(m_audioRecorder);
    m_captureSession.setAudioInput(new QAudioInput(this));
}

AudioRecorder::~AudioRecorder()
{
}

QString AudioRecorder::filePath() const
{
    return m_filePath;
}

void AudioRecorder::start()
{
#ifdef Q_OS_ANDROID
    m_audioRecorder->setOutputLocation(QUrl());
#else
    m_audioRecorder->setOutputLocation(QUrl::fromLocalFile(QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/intellicute_recording.wav"));
#endif
    m_captureSession.audioInput()->setDevice(QVariant(QString()).value<QAudioDevice>()); // default
    QMediaFormat mediaFormat(QMediaFormat::FileFormat::Wave);
    mediaFormat.setAudioCodec(QMediaFormat::AudioCodec::Wave);
    m_audioRecorder->setMediaFormat(mediaFormat);
    m_audioRecorder->setAudioSampleRate(44100);
    m_audioRecorder->setAudioBitRate(0); // default
    m_audioRecorder->setQuality(QMediaRecorder::NormalQuality);
    m_audioRecorder->setEncodingMode(QMediaRecorder::ConstantQualityEncoding);
    m_audioRecorder->record();
}

void AudioRecorder::stop()
{
    m_audioRecorder->stop();
#ifdef Q_OS_ANDROID
    // for some reason audio recordings are created in this place instead of wathever is configured
    QDir configPath(QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + "/Music");
    QStringList filters = {"*.m4a"};
    configPath.setNameFilters(filters);
    auto fileList = configPath.entryList(QDir::Files, QDir::Name);
    m_filePath = configPath.filePath(fileList.back());
    // TODO cleanup files from previous runs
#else
    m_filePath = m_audioRecorder->actualLocation().toLocalFile();
#endif
    qDebug() << m_filePath << m_audioRecorder->outputLocation();
    emit filePathChanged();
    // delay recording completed to make sure file is written
    QTimer::singleShot(100, this, &AudioRecorder::recordingComplete);
}
```

### `awesome_chatgpt_prompts.cpp`
```cpp
#include "awesome_chatgpt_prompts.h"

AwesomeChatGptPrompts::AwesomeChatGptPrompts(QObject *parent)
    : QObject(parent)
{

}

AwesomeChatGptPrompts::~AwesomeChatGptPrompts()
{

}

// TODO
struct MarkdownContent {
    QString title;
    QString author;
    QString referenceUrl;
    QString codeBlock;
};

void parseMarkdownFile(QString filePath)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        return;

    QTextStream in(&file);
    QString line;
    bool startParsing = false;
    MarkdownContent content;

    while (!in.atEnd()) {
        line = in.readLine();

        if (line.startsWith("# Prompts")) {
            startParsing = true;
            continue;
        }

        if (startParsing) {
            if (line.startsWith("## ")) {
                // found a new section, save the previous content
                if (!content.title.isEmpty()) {
                    // do something with the extracted content
                    qDebug() << "Title:" << content.title;
                    qDebug() << "Author:" << content.author;
                    qDebug() << "Reference URL:" << content.referenceUrl;
                    qDebug() << "Code Block:" << content.codeBlock;
                }
                // start a new content section
                content = MarkdownContent();
                content.title = line.mid(3);
            } else if (line.startsWith("Contributed by:")) {
                content.author = line.mid(16, line.indexOf("]") - 16);
                content.referenceUrl = line.mid(line.indexOf("(") + 1, line.indexOf(")") - line.indexOf("(") - 1);
            } else if (line.startsWith("```")) {
                // found a code block, extract the content
                while (!in.atEnd()) {
                    line = in.readLine();
                    if (line.startsWith("```"))
                        break;
                    content.codeBlock += line + "\n";
                }
            }
        }
    }

    // save the last content section
    if (!content.title.isEmpty()) {
        // do something with the extracted content
        qDebug() << "Title:" << content.title;
        qDebug() << "Author:" << content.author;
        qDebug() << "Reference URL:" << content.referenceUrl;
        qDebug() << "Code Block:" << content.codeBlock;
    }

    file.close();
}```

### `fileio.cpp`
```cpp
#include "fileio.h"
#include <QFile>

FileIO::FileIO(QObject *parent)
    : QObject(parent)
    , m_error(false)
{
}

bool FileIO::read()
{
    QString filePath;
    if (m_filePath.isLocalFile()) {
        filePath = m_filePath.toLocalFile();
    }
    else {
        filePath = m_filePath.toString();
    }

    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        m_error = true;
        m_errorString = tr("Could not open file for reading");
        emit errorStringChanged();
        return false;
    }
    else {
        m_error = false;
        m_errorString = QString();
        emit errorStringChanged();
    }

    m_text = QString::fromUtf8(file.readAll());
    file.close();

    emit textChanged();
    return true;
}

bool FileIO::write()
{
    QString filePath;
    if (m_filePath.isLocalFile()) {
        filePath = m_filePath.toLocalFile();
    }
    else {
        filePath = m_filePath.toString();
    }

    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        m_error = true;
        m_errorString = tr("Could not open file for writing");
        emit errorStringChanged();
        return false;
    }
    else {
        m_error = false;
        m_errorString = QString();
        emit errorStringChanged();
    }

    file.write(m_text.toUtf8());
    file.close();

    return true;
}

QUrl FileIO::filePath() const
{
    return m_filePath;
}

void FileIO::setFilePath(const QUrl &filePath)
{
    if (m_filePath == filePath)
        return;

    m_filePath = filePath;
    emit filePathChanged();
}

QString FileIO::text() const
{
    return m_text;
}

void FileIO::setText(const QString &text)
{
    if (m_text == text)
        return;

    m_text = text;
    emit textChanged();
}

QString FileIO::errorString() const
{
    return m_errorString;
}

bool FileIO::hasError() const
{
    return m_error;
}
```

### `json_mapper.cpp`
```cpp
#include <QJsonDocument>
#include <QJsonObject>
#include <QQmlPropertyMap>

class JsonMapper : public QObject
{
    Q_OBJECT

public:
    explicit JsonMapper(QObject *parent = nullptr) : QObject(parent) {}

    Q_INVOKABLE QQmlPropertyMap* mapJson(const QString& filePath) {
        QFile file(filePath);
        if (!file.open(QIODevice::ReadOnly)) {
            qWarning() << "Could not open file for reading:" << filePath;
            return nullptr;
        }

        QByteArray jsonData = file.readAll();
        QJsonDocument jsonDoc = QJsonDocument::fromJson(jsonData);

        if (!jsonDoc.isObject()) {
            qWarning() << "JSON data is not an object:" << filePath;
            return nullptr;
        }

        QJsonObject jsonObj = jsonDoc.object();
        QQmlPropertyMap* map = new QQmlPropertyMap();
        for (auto it = jsonObj.begin(); it != jsonObj.end(); ++it) {
            QString key = it.key();
            QVariant value = mapJsonValue(it.value());
            map->insert(key, value);
        }

        return map;
    }

private:
    QVariant mapJsonValue(const QJsonValue& jsonValue) {
        if (jsonValue.isObject()) {
            QJsonObject jsonObj = jsonValue.toObject();
            QQmlPropertyMap* map = new QQmlPropertyMap();
            for (auto it = jsonObj.begin(); it != jsonObj.end(); ++it) {
                QString key = it.key();
                QVariant value = mapJsonValue(it.value());
                map->insert(key, value);
            }
            return QVariant::fromValue(map);
        } else {
            return jsonValue.toVariant();
        }
    }
};```

### `main.cpp`
```cpp
#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QCommandLineParser>
#include <QFile>
#include <QIcon>
#include <QFontDatabase>


int main(int argc, char *argv[])
{
#ifdef QT_DEBUG
    qDebug() << qgetenv("LD_LIBRARY_PATH");
#endif

    QGuiApplication app(argc, argv);
    app.setOrganizationName(u"Machine Koder"_qs);
    app.setOrganizationDomain(u"machinekoder.com"_qs);
    app.setApplicationName(u"Intellicute"_qs);
    app.setApplicationVersion(u"1.0"_qs);

    // set icon from resource
    app.setWindowIcon(QIcon(u":/icons/intellicute_512.png"_qs));

    QCommandLineParser parser;
    parser.setApplicationDescription("Intellicute, a Qt AI Assistant");
    parser.addHelpOption();
#ifdef QT_DEBUG
    QCommandLineOption forceOption(QStringList() << "l" << "live",
    QCoreApplication::translate("live", "Start live coding mode."));
    parser.addOption(forceOption);
#endif
    parser.process(app);

    QString fileName = u"main.qml"_qs;
    #ifdef QT_DEBUG
        if (parser.isSet(forceOption)) {
            fileName = u"live.qml"_qs;
        }
    #endif

    if (QFontDatabase::addApplicationFont(":/fonts/fa-solid-900.ttf") == -1) {
        qWarning() << "Failed to load fonts";
    }

    QQmlApplicationEngine engine;
    QFile file(u"./"_qs + fileName);
    QUrl url;
    if (file.exists()) {
        url = u"./"_qs + fileName;
        qputenv("QT_QUICK_CONTROLS_CONF", "qtquickcontrols2.conf");
    }
    else {
        engine.addImportPath(u"qrc:/"_qs);
        url = u"qrc:/"_qs + fileName;
        qputenv("QT_QUICK_CONTROLS_CONF", ":/qtquickcontrols2.conf");
    }
    QObject::connect(&engine, &QQmlApplicationEngine::objectCreated,
                     &app, [url](QObject *obj, const QUrl &objUrl) {
        if (!obj && url == objUrl)
            QCoreApplication::exit(-1);
    }, Qt::QueuedConnection);
    engine.load(url);

    return app.exec();
}
```

### `openai_message.cpp`
```cpp
#include "openai_message.h"

OpenAIMessage::OpenAIMessage(QObject *parent):
    QObject(parent)
{

}

OpenAIMessage::OpenAIMessage(const QString& content, OpenAIMessage::Role role, QObject *parent):
    QObject(parent),
    m_content(content),
    m_role(role)
{

}


OpenAIMessage::~OpenAIMessage()
{

}


QString OpenAIMessage::content() const
{
    return m_content;
}

void OpenAIMessage::setContent(const QString& content)
{
    if (m_content != content) {
        m_content = content;
        emit contentChanged();
    }
}

OpenAIMessage::Role OpenAIMessage::role() const
{
    return m_role;
}

void OpenAIMessage::setRole(OpenAIMessage::Role role)
{
    if (m_role != role) {
        m_role = role;
        emit roleChanged();
    }
}
```

### `openai_message_model.cpp`
```cpp
#include "openai_message_model.h"

OpenAIMessageModel::OpenAIMessageModel(QObject *parent)
    : QAbstractListModel(parent)
{
    connect(this, &OpenAIMessageModel::messagesChanged, this, &OpenAIMessageModel::jsonStringChanged);
}

OpenAIMessageModel::~OpenAIMessageModel()
{
}

int OpenAIMessageModel::rowCount(const QModelIndex &parent) const
{
    if (parent.isValid())
        return 0;

    return m_messages.count();
}

QVariant OpenAIMessageModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid())
        return QVariant();

    OpenAIMessage *message = m_messages.at(index.row());

    switch (role) {
    case MessageRole:
        return QVariant::fromValue(message);
    case RoleRole:
        return QVariant::fromValue(message->role());
    default:
        return QVariant();
    }
}

QHash<int, QByteArray> OpenAIMessageModel::roleNames() const
{
    QHash<int, QByteArray> roles;
    roles[MessageRole] = "message";
    roles[RoleRole] = "role";
    return roles;
}

void OpenAIMessageModel::addMessage(OpenAIMessage *message)
{
    beginInsertRows(QModelIndex(), m_messages.count(), m_messages.count());
    m_messages.append(message);
    endInsertRows();
    emit messagesChanged();
}

void OpenAIMessageModel::addMessage(OpenAIMessage::Role role, const QString &content)
{
    OpenAIMessage *message = new OpenAIMessage(content, role);
    addMessage(message);
}

void OpenAIMessageModel::removeMessage(OpenAIMessage *message)
{
    int pos = m_messages.indexOf(message);
    if (pos != -1) {
        beginRemoveRows(QModelIndex(), pos, pos);
        m_messages.removeAt(pos);
        endRemoveRows();
        emit messagesChanged();
        message->deleteLater();
    }
}

void OpenAIMessageModel::clearMessages()
{
    beginResetModel();
    for (OpenAIMessage *message : m_messages) {
        message->deleteLater();
    }
    m_messages.clear();
    endResetModel();
    emit messagesChanged();
}

QList<OpenAIMessage *> OpenAIMessageModel::messagesFromJson(const QString &jsonString) const
{
    QList<OpenAIMessage *> messages;
    QJsonDocument jsonDocument = QJsonDocument::fromJson(jsonString.toUtf8());
    if (jsonDocument.isNull()) {
        qWarning() << "Failed to read JSON document";
        return messages;
    }
    // read "messages" from json object
    QJsonObject jsonObject = jsonDocument.object();
    if (!jsonObject.contains("messages")) {
        qWarning() << "JSON document does not contain 'messages' key";
        return messages;
    }
    QJsonArray jsonArray = jsonObject["messages"].toArray();
    for (const QJsonValue &jsonValue : jsonArray) {
        QJsonObject messageObject = jsonValue.toObject();
        if (!messageObject.contains("role") || !messageObject.contains("content")) {
            qWarning() << "JSON document does not contain 'role' or 'content' key";
            continue;
        }
        OpenAIMessage *message = new OpenAIMessage(
            messageObject["content"].toString(),
            OpenAIMessage::roleFromString(messageObject["role"].toString())
            );
        messages.append(message);
    }
    return messages;
}

QString OpenAIMessageModel::jsonFromMessages(const QList<OpenAIMessage*> &messages) const
{
    QJsonArray jsonArray;
    for (OpenAIMessage *message : messages) {
        QJsonObject messageObject;
        messageObject["role"] = OpenAIMessage::roleToString(message->role());
        messageObject["content"] = message->content();
        jsonArray.append(messageObject);
    }
    QJsonObject jsonObject;
    jsonObject["messages"] = jsonArray;
    QJsonDocument jsonDocument(jsonObject);
    return jsonDocument.toJson(QJsonDocument::Indented);
}

QList<OpenAIMessage *> OpenAIMessageModel::messages() const
{
    return m_messages;
}

void OpenAIMessageModel::setMessages(const QList<OpenAIMessage *> &newMessages)
{
    if (m_messages == newMessages)
        return;
    beginResetModel();
    m_messages = newMessages;
    endResetModel();
    emit messagesChanged();
}

QString OpenAIMessageModel::jsonString() const
{
    return jsonFromMessages(m_messages);
}

void OpenAIMessageModel::setJsonString(const QString &newJsonString)
{
    setMessages(messagesFromJson(newJsonString));
}
```

### `openai_request.cpp`
```cpp
#include <QObject>
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QUrl>
#include <QUrlQuery>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QHttpMultiPart>
#include <QHttpPart>

#include "openai_request.hpp"

OpenAIRequest::OpenAIRequest(QObject *parent)
    : QObject(parent)
    , m_networkAccessManager(new QNetworkAccessManager(this))
    , m_accessToken("")
    , m_model("")
    , m_prompt("")
    , m_filePath("")
    , m_generatedText("")
    , m_errorString("")
    , m_status(RequestStatus::Idle)
    , m_maxTokens(100)
    , m_temperature(0.3)
    , m_topP(1.0)
    , m_frequencyPenalty(0.0)
    , m_presencePenalty(0.0)
{
    connect(this, &OpenAIRequest::requestFinished, this, [this](const QString& generatedText) {
        m_generatedText = generatedText;
        emit generatedTextChanged();
        m_status = RequestStatus::Success;
        emit statusChanged();
    });
    connect(this, &OpenAIRequest::requestError, this, [this](const QString& errorString) {
        m_errorString = errorString;
        emit errorStringChanged();
        m_status = RequestStatus::Error;
        emit statusChanged();
    });
}

OpenAIRequest::~OpenAIRequest()
{
    for (OpenAIMessage *message : m_messages) {
        message->deleteLater();
    }
    m_messages.clear();
}

void OpenAIRequest::execute()
{
    if (m_model.startsWith("whisper")) {
        sendMultiPartRequest();
    }
    else if (m_model.startsWith("gpt-3")) {
        sendChatRequest();
    }
    else {
        sendRequest();
    }
}

// Send a request to the OpenAI API
void OpenAIRequest::sendRequest()
{
    // Set up the API endpoint URL
    const QUrl endpointUrl("https://api.openai.com/v1/completions");

    // Set up the request headers
    QNetworkRequest request(endpointUrl);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setRawHeader("Authorization", ("Bearer " + m_accessToken).toUtf8());

    // Set up the request body
    QJsonObject requestBody;
    requestBody.insert("model", m_model);
    requestBody.insert("prompt", m_prompt);
    requestBody.insert("max_tokens", m_maxTokens);
    requestBody.insert("temperature", m_temperature);
    requestBody.insert("top_p", m_topP);
    requestBody.insert("frequency_penalty", m_frequencyPenalty);
    requestBody.insert("presence_penalty", m_presencePenalty);

    QJsonDocument requestBodyJson(requestBody);
    QByteArray requestBodyBytes = requestBodyJson.toJson();

    // Send the request
    QNetworkReply *reply = m_networkAccessManager->post(request, requestBodyBytes);
    m_status = RequestStatus::InProgress;
    emit statusChanged();

    // Connect signals and slots to handle the response
    connect(reply, &QNetworkReply::finished, this, [this, reply]() {
        if (reply->error() == QNetworkReply::NoError) {
            const QByteArray responseBytes = reply->readAll();
            const QJsonDocument responseJson = QJsonDocument::fromJson(responseBytes);

            // Handle the response
            const QString generatedText = responseJson.object().value("choices").toArray().at(0).toObject().value("text").toString();
            emit requestFinished(generatedText);
        } else {
            emit requestError(reply->errorString());
        }

        reply->deleteLater();
    });
}

void OpenAIRequest::sendChatRequest()
{
    // Set up the API endpoint URL
    const QUrl endpointUrl("https://api.openai.com/v1/chat/completions");

    // Set up the request headers
    QNetworkRequest request(endpointUrl);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    request.setRawHeader("Authorization", ("Bearer " + m_accessToken).toUtf8());

    // Set up the request body
    QJsonObject requestBody;
    requestBody.insert("model", m_model);
    requestBody.insert("max_tokens", m_maxTokens);
    requestBody.insert("temperature", m_temperature);
    requestBody.insert("top_p", m_topP);
    requestBody.insert("frequency_penalty", m_frequencyPenalty);
    requestBody.insert("presence_penalty", m_presencePenalty);
    QJsonArray messageArray;
    auto addMessageArray = [this, &messageArray](OpenAIMessage* message) {
        if (message->content().isEmpty())
            return;
        QJsonObject messageObject;
        messageObject.insert("role", OpenAIMessage::roleToString(message->role()));
        messageObject.insert("content", message->content());
        messageArray.append(messageObject);
    };
    for (OpenAIMessage *message : m_messages) {
        addMessageArray(message);
    }
    requestBody.insert("messages", messageArray);

    QJsonDocument requestBodyJson(requestBody);
    QByteArray requestBodyBytes = requestBodyJson.toJson();

    // Send the request
    QNetworkReply *reply = m_networkAccessManager->post(request, requestBodyBytes);
    m_status = RequestStatus::InProgress;
    emit statusChanged();

    // Connect signals and slots to handle the response
    connect(reply, &QNetworkReply::finished, this, [this, reply]() {
        if (reply->error() == QNetworkReply::NoError) {
            const QByteArray responseBytes = reply->readAll();
            const QJsonDocument responseJson = QJsonDocument::fromJson(responseBytes);

            // Handle the response
            const auto message = responseJson.object().value("choices").toArray().at(0).toObject().value("message").toObject();
            //addMessage(OpenAIMessage::roleFromString(message.value("role").toString()), message.value("content").toString());
            emit requestFinished(message.value("content").toString());
        } else {
            emit requestError(reply->errorString() + reply->readAll());
        }

        reply->deleteLater();
    });
}

void OpenAIRequest::sendMultiPartRequest()
{
    // Set up the API endpoint URL
    const QUrl endpointUrl("https://api.openai.com/v1/audio/transcriptions");

    // Set up the request headers
    QNetworkRequest request(endpointUrl);
    request.setRawHeader("Authorization", ("Bearer " + m_accessToken).toUtf8());

    // Set up the form data
    QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);

    // Add a JSON parameter
    QHttpPart modelPart;
    modelPart.setHeader(QNetworkRequest::ContentTypeHeader, "text/plain");
    modelPart.setHeader(QNetworkRequest::ContentDispositionHeader, "form-data; name=\"model\"");
    modelPart.setBody(m_model.toUtf8());

    QHttpPart filePart;
    filePart.setHeader(QNetworkRequest::ContentTypeHeader, "audio/wav");
    filePart.setHeader(QNetworkRequest::ContentDispositionHeader, "form-data; name=\"file\"; filename=\"audio.wav\"");
    QFile *file = new QFile(m_filePath);
    file->open(QIODevice::ReadOnly);
    filePart.setBodyDevice(file);
    file->setParent(multiPart); // Ownership transfer

    multiPart->append(filePart);
    multiPart->append(modelPart);

    // Send the request
    QNetworkReply *reply = m_networkAccessManager->post(request, multiPart);
    multiPart->setParent(reply); // Ownership transfer
    m_status = RequestStatus::InProgress;
    emit statusChanged();

    // Connect signals and slots to handle the response
    connect(reply, &QNetworkReply::finished, this, [this, file, reply]() {
        file->close();
        if (reply->error() == QNetworkReply::NoError) {
            const QByteArray responseBytes = reply->readAll();
            const QJsonDocument responseJson = QJsonDocument::fromJson(responseBytes);

            // Handle the response
            const QString generatedText = responseJson.object().value("text").toString();
            emit requestFinished(generatedText);
        } else {
            qDebug() << reply->errorString();
            emit requestError(reply->errorString());
        }

        reply->deleteLater();
    });
}

QString OpenAIRequest::accessToken() const
{
    return m_accessToken;
}

void OpenAIRequest::setAccessToken(const QString& accessToken)
{
    if (m_accessToken == accessToken)
        return;
    m_accessToken = accessToken;
    emit accessTokenChanged();
}

QString OpenAIRequest::model() const
{
    return m_model;
}

void OpenAIRequest::setModel(const QString& model)
{
    if (m_model == model)
        return;
    m_model = model;
    emit modelChanged();
}

QString OpenAIRequest::prompt() const
{
    return m_prompt;
}

void OpenAIRequest::setPrompt(const QString& prompt)
{
    if (m_prompt == prompt)
        return;
    m_prompt = prompt;
    emit promptChanged();
}

QString OpenAIRequest::filePath() const
{
    return m_filePath;
}

void OpenAIRequest::setFilePath(const QString& filePath)
{
    if (m_filePath == filePath)
        return;
    m_filePath = filePath;
    emit filePathChanged();
}

QString OpenAIRequest::generatedText() const
{
    return m_generatedText;
}

QString OpenAIRequest::errorString() const
{
    return m_errorString;
}

OpenAIRequest::RequestStatus OpenAIRequest::status() const
{
    return m_status;
}

int OpenAIRequest::maxTokens() const
{
    return m_maxTokens;
}

void OpenAIRequest::setMaxTokens(int maxTokens)
{
    if (m_maxTokens == maxTokens)
        return;
    m_maxTokens = maxTokens;
    emit maxTokensChanged();
}

double OpenAIRequest::temperature() const
{
    return m_temperature;
}

void OpenAIRequest::setTemperature(double temperature)
{
    if (qFuzzyCompare(m_temperature, temperature))
        return;
    m_temperature = temperature;
    emit temperatureChanged();
}

double OpenAIRequest::topP() const
{
    return m_topP;
}

void OpenAIRequest::setTopP(double topP)
{
    if (qFuzzyCompare(m_topP, topP))
        return;
    m_topP = topP;
    emit topPChanged();
}

double OpenAIRequest::frequencyPenalty() const
{
    return m_frequencyPenalty;
}

void OpenAIRequest::setFrequencyPenalty(double frequencyPenalty)
{
    if (qFuzzyCompare(m_frequencyPenalty, frequencyPenalty))
        return;
    m_frequencyPenalty = frequencyPenalty;
    emit frequencyPenaltyChanged();
}

double OpenAIRequest::presencePenalty() const
{
    return m_presencePenalty;
}

void OpenAIRequest::setPresencePenalty(double presencePenalty)
{
    if (qFuzzyCompare(m_presencePenalty, presencePenalty))
        return;
    m_presencePenalty = presencePenalty;
    emit presencePenaltyChanged();
}

QList<OpenAIMessage*> OpenAIRequest::messages() const
{
    return m_messages;
}

void OpenAIRequest::setMessages(const QList<OpenAIMessage *> &newMessages)
{
    if (m_messages == newMessages)
        return;
    m_messages = newMessages;
    emit messagesChanged();
}
```

### `watson_tts_request.cpp`
```cpp
#include "watson_tts_request.h"
#include <QNetworkAccessManager>
#include <QNetworkReply>
#include <QUrl>
#include <QUrlQuery>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QStandardPaths>


WatsonTTSRequest::WatsonTTSRequest(QObject *parent)
    : QObject(parent)
    , m_networkAccessManager(new QNetworkAccessManager(this))
    , m_accessToken("")
    , m_voice("")
    , m_text("")
    , m_apiURL("")
    , m_filePath("")
    , m_errorString("")
    , m_status(RequestStatus::Idle)
{
    m_filePath = QStandardPaths::writableLocation(QStandardPaths::TempLocation) + "/watson_tts.ogg";
}

WatsonTTSRequest::~WatsonTTSRequest()
{

}

void WatsonTTSRequest::sendRequest()
{
    // Set up the API endpoint URL
    QUrl endpointUrl = m_apiURL.resolved(QUrl("v1/synthesize"));

    QUrlQuery params;
    params.addQueryItem("voice", m_voice);
    endpointUrl.setQuery(params);

    // Set up the request headers
    QNetworkRequest request(endpointUrl);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    //request.setRawHeader("Authorization", "Bearer " + m_accessToken.toUtf8());
    request.setRawHeader("Authorization", "Basic " + QString("apikey:" + m_accessToken).toLocal8Bit().toBase64());
    //request.setRawHeader("Accept", "audio/wav");
    request.setRawHeader("Accept", "audio/ogg;codecs=vorbis");

    // Set up the request body
    QJsonObject requestBody;
    requestBody.insert("text", m_text);

    // Send the request
    QNetworkReply *reply = m_networkAccessManager->post(request, QJsonDocument(requestBody).toJson(QJsonDocument::Compact));
    m_status = RequestStatus::InProgress;
    emit statusChanged();

    // Connect signals and slots to handle the response
    connect(reply, &QNetworkReply::finished, this, [this, reply]() {
        if (reply->error() == QNetworkReply::NoError) {
            QFile saveFile(m_filePath);
            if (saveFile.open(QIODevice::WriteOnly)) {
                saveFile.write(reply->readAll());
                saveFile.close();
                m_status = RequestStatus::Success;
                emit statusChanged();
                emit requestFinished();
            } else {
                m_errorString = "Could not open file for writing";
                emit errorStringChanged();
                m_status = RequestStatus::Error;
                emit statusChanged();
                emit requestError(m_errorString);
            }
        } else {
            m_errorString = reply->errorString();
            qDebug() << reply->error() << reply->errorString() << reply->readAll();
            emit errorStringChanged();
            m_status = RequestStatus::Error;
            emit statusChanged();
            emit requestError(m_errorString);
        }

        reply->deleteLater();
    });
}

void WatsonTTSRequest::execute()
{
    sendRequest();
}

QString WatsonTTSRequest::accessToken() const
{
    return m_accessToken;
}

void WatsonTTSRequest::setAccessToken(const QString& accessToken)
{
    if (m_accessToken != accessToken) {
        m_accessToken = accessToken;
        emit accessTokenChanged();
    }
}

QString WatsonTTSRequest::voice() const
{
    return m_voice;
}

void WatsonTTSRequest::setVoice(const QString& voice)
{
    if (m_voice != voice) {
        m_voice = voice;
        emit voiceChanged();
    }
}

QString WatsonTTSRequest::text() const
{
    return m_text;
}

void WatsonTTSRequest::setText(const QString& text)
{
    if (m_text != text) {
        m_text = text;
        emit textChanged();
    }
}

QUrl WatsonTTSRequest::apiURL() const
{
    return m_apiURL;
}

void WatsonTTSRequest::setApiURL(const QUrl& apiURL)
{
    if (m_apiURL != apiURL) {
        m_apiURL = apiURL;
        emit apiURLChanged();
    }
}

QString WatsonTTSRequest::filePath() const
{
    return m_filePath;
}

QString WatsonTTSRequest::errorString() const
{
    return m_errorString;
}

WatsonTTSRequest::RequestStatus WatsonTTSRequest::status() const
{
    return m_status;
}
```

### `audio_recorder.hpp`
```cpp
#pragma once
#include <QObject>
#include <QMediaRecorder>
#include <QMediaCaptureSession>
#include <QUrl>
#include <QtQml>


class AudioRecorder: public QObject
{
    Q_OBJECT
    QML_ELEMENT

    Q_PROPERTY(QString filePath READ filePath NOTIFY filePathChanged)

    public:
        explicit AudioRecorder(QObject *parent = nullptr);
        virtual ~AudioRecorder();

    public slots:
        QString filePath() const;

        void start();
        void stop();

    signals:
        void filePathChanged();
        void recordingComplete();

    private:
        QString m_filePath;
        QMediaCaptureSession m_captureSession;
        QMediaRecorder *m_audioRecorder = nullptr;
};
```

### `openai_request.hpp`
```cpp
#pragma once

#include <QObject>
#include <QNetworkAccessManager>
#include <QtQml>

#include "openai_message.h"


class OpenAIRequest : public QObject
{
    Q_OBJECT
    QML_ELEMENT

    Q_PROPERTY(QString accessToken READ accessToken WRITE setAccessToken NOTIFY accessTokenChanged)
    Q_PROPERTY(QString model READ model WRITE setModel NOTIFY modelChanged)
    Q_PROPERTY(QString prompt READ prompt WRITE setPrompt NOTIFY promptChanged)
    Q_PROPERTY(QString filePath READ filePath WRITE setFilePath NOTIFY filePathChanged)
    Q_PROPERTY(QString generatedText READ generatedText NOTIFY generatedTextChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_PROPERTY(RequestStatus status READ status NOTIFY statusChanged)
    Q_PROPERTY(int maxTokens READ maxTokens WRITE setMaxTokens NOTIFY maxTokensChanged)
    Q_PROPERTY(double temperature READ temperature WRITE setTemperature NOTIFY temperatureChanged)
    Q_PROPERTY(double topP READ topP WRITE setTopP NOTIFY topPChanged)
    Q_PROPERTY(double frequencyPenalty READ frequencyPenalty WRITE setFrequencyPenalty NOTIFY frequencyPenaltyChanged)
    Q_PROPERTY(double presencePenalty READ presencePenalty WRITE setPresencePenalty NOTIFY presencePenaltyChanged)
    Q_PROPERTY(QList<OpenAIMessage*> messages READ messages WRITE setMessages NOTIFY messagesChanged)

    Q_ENUMS(RequestStatus)

public:
    explicit OpenAIRequest(QObject *parent = nullptr);
    virtual ~OpenAIRequest();

    enum class RequestStatus {
        Idle,
        InProgress,
        Error,
        Success
    };

public slots:
    QString accessToken() const;
    void setAccessToken(const QString& accessToken);

    QString model() const;
    void setModel(const QString& model);

    QString prompt() const;
    void setPrompt(const QString& prompt);

    QString filePath() const;
    void setFilePath(const QString& filePath);

    QString generatedText() const;
    QString errorString() const;
    RequestStatus status() const;

    int maxTokens() const;
    void setMaxTokens(int maxTokens);

    double temperature() const;
    void setTemperature(double temperature);

    double topP() const;
    void setTopP(double topP);

    double frequencyPenalty() const;
    void setFrequencyPenalty(double frequencyPenalty);

    double presencePenalty() const;
    void setPresencePenalty(double presencePenalty);

    QList<OpenAIMessage*> messages() const;
    void setMessages(const QList<OpenAIMessage *> &newMessages);

    // execute a request
    void execute();

signals:
    // Signal emitted when the request is finished successfully
    void requestFinished(const QString& generatedText);

    // Signal emitted when the request encounters an error
    void requestError(const QString& errorString);

    void accessTokenChanged();
    void modelChanged();
    void promptChanged();
    void filePathChanged();
    void generatedTextChanged();
    void errorStringChanged();
    void statusChanged();
    void maxTokensChanged();
    void temperatureChanged();
    void topPChanged();
    void frequencyPenaltyChanged();
    void presencePenaltyChanged();
    void messagesChanged();

private:
    QNetworkAccessManager *m_networkAccessManager;
    QString m_accessToken;
    QString m_model;
    QString m_prompt;
    QString m_filePath;
    QString m_generatedText;
    QString m_errorString;
    RequestStatus m_status;
    int m_maxTokens;
    double m_temperature;
    double m_topP;
    double m_frequencyPenalty;
    double m_presencePenalty;
    QList<OpenAIMessage*> m_messages;

    void sendRequest();
    void sendChatRequest();
    void sendMultiPartRequest();
};
```

### `ChatPage.qml`
```cpp
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import QtQuick.Dialogs
import QtTextToSpeech
import QtMultimedia
import QtCore
import Qt.labs.settings
import Intellicute
import core

Page {
    id: root

    property string defaultMessages: JSON.stringify(
                                         root.settings.chat.defaultMessages)
    required property var settings

    signal settingsRequested

    function resetSettings() {
        root.settings = root.defaultSettings
    }

    QtObject {
        id: d

        function sendGptRequest() {
            if (input.text.length > 0) {
                messageModel.addMessage(OpenAIMessage.User, input.text)
                input.text = ""
            }
            gptRequest.execute() // might be too soon -> delay
        }

        function speak(text) {
            if (root.settings.tts.watson.use) {
                watsonTts.text = text
                watsonTts.execute()
            } else {
                tts.say(text)
            }
        }

        function resetChat() {
            messageModel.clearMessages()
            messageModel.jsonString = root.defaultMessages
        }
    }

    TextToSpeech {
        id: tts
        //engine: "speechd"
        locale: Qt.locale(root.settings.tts.locale)
    }

    WatsonTTSRequest {
        id: watsonTts
        accessToken: root.settings.tts.watson.apiKey
        voice: root.settings.tts.watson.voice
        apiURL: root.settings.tts.watson.apiUrl

        onRequestFinished: {
            console.log("Watson TTS finished")
            player.source = ""
            player.source = "file://" + watsonTts.filePath
            player.play()
        }
        onErrorStringChanged: console.log(errorString)
    }

    MediaPlayer {
        id: player
        audioOutput: AudioOutput {
            muted: false
            volume: 1.0
        }
    }

    OpenAIRequest {
        id: whisperRequest
        accessToken: root.settings.openai.accessToken
        model: "whisper-1"
        filePath: recorder.filePath
        onErrorStringChanged: console.log(errorString)
        onStatusChanged: {
            if (status === OpenAIRequest.Success
                    && (generatedText.length > 0)) {
                input.text = generatedText
                d.sendGptRequest()
            }
        }
    }

    AudioRecorder {
        id: recorder
        onRecordingComplete: {
            console.log("Recording complete")
            console.log(recorder.filePath)
            whisperRequest.execute()
        }
    }

    OpenAIRequest {
        id: gptRequest
        accessToken: root.settings.openai.accessToken
        model: root.settings.chat.model
        maxTokens: root.settings.chat.maxTokens
        temperature: root.settings.chat.temperature
        topP: root.settings.chat.topP
        frequencyPenalty: root.settings.chat.frequencyPenalty
        presencePenalty: root.settings.chat.presencePenalty
        messages: messageModel.messages
        onRequestFinished: generatedText => {
                               console.log("GPT request finished")
                               messageModel.addMessage(OpenAIMessage.Assistant,
                                                       generatedText)
                               if (root.settings.tts.autoplay) {
                                   d.speak(generatedText)
                               }
                           }
        onRequestError: errorString => {
                            console.log("GPT request error: " + errorString)
                        }
    }

    OpenAIMessageModel {
        id: messageModel
    }

    Settings {
        id: messageStore
        category: "chat"
        property alias messages: messageModel.jsonString
    }

    Settings {
        id: pathSettings
        category: "paths"
        property alias importPath: importChatDialog.currentFolder
        property alias exportPath: exportChatDialog.currentFolder
    }

    FileDialog {
        id: importChatDialog
        title: qsTr("Import Chat File")
        currentFolder: StandardPaths.writableLocation(
                           StandardPaths.DocumentsLocation)
        acceptLabel: qsTr("Import")
        nameFilters: [qsTr("Chat Files (*.chat.json)")]
        defaultSuffix: "chat.json"
        fileMode: FileDialog.OpenFile
        onAccepted: {
            readFileIo.filePath = importChatDialog.selectedFile
            readFileIo.read()
            if (readFileIo.hasError) {
                console.error(readFileIo.errorString)
            }
        }

        FileIO {
            id: readFileIo
            onTextChanged: {
                if (readFileIo.text) {
                    messageModel.jsonString = readFileIo.text
                }
            }
        }
    }

    FileDialog {
        id: exportChatDialog
        title: qsTr("Export Chat File")
        currentFolder: StandardPaths.writableLocation(
                           StandardPaths.DocumentsLocation)
        acceptLabel: qsTr("Export")
        nameFilters: [qsTr("Chat Files (*.chat.json)")]
        defaultSuffix: ".chat.json"
        fileMode: FileDialog.SaveFile
        onAccepted: {
            writeFileIo.text = messageModel.jsonString
            writeFileIo.filePath = exportChatDialog.selectedFile
            writeFileIo.write()
            if (writeFileIo.hasError) {
                console.error(writeFileIo.errorString)
            }
        }

        FileIO {
            id: writeFileIo
        }
    }

    ColumnLayout {
        anchors.fill: parent
        anchors.margins: Style.singleMargin

        SplitView {
            Layout.fillWidth: true
            Layout.fillHeight: true

            Rectangle {
                color: "green"
                SplitView.preferredWidth: 150
                clip: true
                visible: false

                ListView {
                    id: sessionView
                    anchors.fill: parent
                    anchors.margins: Style.singleMargin
                    spacing: Style.spacing
                    model: 5
                    delegate: Rectangle {
                        id: item
                        required property int index
                        width: sessionView.width
                        height: 50
                        color: "lightgreen"

                        Text {
                            anchors.centerIn: parent
                            text: qsTr("Chat %1").arg(item.index + 1)
                        }
                    }
                }
            }

            Rectangle {
                SplitView.preferredWidth: 500
                color: "white"
                clip: true

                ChatView {
                    id: chatView
                    anchors.fill: parent
                    anchors.margins: Style.singleMargin
                    model: messageModel
                    ttsActive: watsonTts.status === WatsonTTSRequest.InProgress
                    onSpeak: message => {
                                 d.speak(message)
                             }
                    onRemoveMessage: message => {
                                         messageModel.removeMessage(message)
                                     }
                }
            }
        }

        RowLayout {
            Layout.preferredHeight: 150
            Layout.fillHeight: false

            TextArea {
                id: input
                Layout.fillWidth: true
                Layout.fillHeight: true
                readOnly: gptRequest.status === OpenAIRequest.InProgress
                placeholderText: qsTr("Enter your prompt here")
                wrapMode: TextArea.WordWrap

                background: Rectangle {
                    color: "white"
                    border.color: "lightgray"
                    border.width: 2
                }

                Keys.onReturnPressed: event => {
                                          if (event.modifiers === Qt.ShiftModifier) {
                                              event.accepted = false
                                              return
                                          }

                                          d.sendGptRequest()
                                      }
            }

            ColumnLayout {
                Layout.fillHeight: true

                RecordButton {
                    id: recordButton
                    Layout.fillHeight: true
                    onCheckedChanged: {
                        if (checked) {
                            recorder.start()
                        } else {
                            recorder.stop()
                        }
                    }

                    Shortcut {
                        sequence: "Ctrl+Space"
                        onActivated: recordButton.checked = !recordButton.checked
                    }
                }

                Button {
                    id: sendButton
                    Layout.fillHeight: true
                    text: "\uf1d8"
                    font.family: Style.iconFont
                    font.pixelSize: 24
                    enabled: gptRequest.status !== OpenAIRequest.InProgress
                    onClicked: d.sendGptRequest()
                }
            }
        }

        RowLayout {

            Button {
                id: resetButton
                text: qsTr("Reset")
                onClicked: {
                    d.resetChat()
                }

                Shortcut {
                    sequence: "Ctrl+R"
                    onActivated: resetButton.clicked()
                }
            }

            Button {
                id: importChatButton
                text: qsTr("Import Chat")

                onClicked: {
                    importChatDialog.open()
                }

                Shortcut {
                    sequence: "Ctrl+O"
                    onActivated: importChatButton.clicked()
                }
            }

            Button {
                id: exportChatButton
                text: qsTr("Export Chat")
                onClicked: {
                    exportChatDialog.open()
                }

                Shortcut {
                    sequence: "Ctrl+S"
                    onActivated: exportChatButton.clicked()
                }
            }

            Button {
                id: stopTtsButton
                text: qsTr("Stop Playback")
                visible: player.playbackState === MediaPlayer.PlayingState
                onClicked: {
                    player.stop()
                }
            }

            Label {
                id: statusLabel
                Layout.fillWidth: true
                horizontalAlignment: Text.AlignHCenter
                text: gptRequest.status
                      === OpenAIRequest.InProgress ? qsTr("Request running") : qsTr(
                                                         "Idle")
                elide: Text.ElideRight
            }

            ToolButton {
                id: settingsButton
                text: "\uf0ad"
                font.pixelSize: 16
                font.family: "awesome"
                onClicked: root.settingsRequested()
            }
        }

        Text {
            Layout.fillWidth: true
            Layout.fillHeight: true
            text: gptRequest.errorString
            visible: gptRequest.status === OpenAIRequest.Error
            elide: Text.ElideRight
            color: "red"
        }
    }
}
```

### `ChatView.qml`
```cpp
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import Intellicute
import core

ListView {
    id: root

    signal speak(message: string)
    signal removeMessage(message: OpenAIMessage)

    property bool ttsEnabled: true
    property bool ttsActive: false

    component FontButton: RoundButton {
        implicitWidth: 32
        implicitHeight: implicitWidth
        text: "\uf0c5"
        font.pixelSize: 16
        font.family: Style.iconFont
    }

    spacing: Style.spacing

    delegate: Rectangle {
        id: item
        required property OpenAIMessage message
        width: root.width
        height: Math.max(messageText.implicitHeight, copyButton.implicitHeight) + 20
        radius: 10
        color: item?.message?.role === OpenAIMessage.User ? "lightblue" : (item?.message?.role === OpenAIMessage.System ? "orange" : "lightgreen")
        border.color: color.darker(0.8)
        border.width: 1

        RowLayout {
            anchors.top: parent.top
            anchors.left: parent.left
            anchors.right: parent.right
            anchors.margins: Style.doubleMargin

            TextEdit {
                id: messageText
                Layout.fillWidth: true
                Layout.fillHeight: true
                text: item?.message?.content ?? ""
                textFormat: markdownRadio.checked ? TextEdit.MarkdownText : (htmlRadio.checked ? TextEdit.RichText : TextEdit.PlainText)
                wrapMode: TextEdit.WordWrap
                verticalAlignment: TextEdit.AlignVCenter
                onEditingFinished: {
                    item.message.content = messageText.text
                }
            }

            RowLayout {
                id: buttonLayout
                Layout.alignment: Qt.AlignBottom
                opacity: mouseArea.containsMouse ? 1.0 : 0.0

                Behavior on opacity { NumberAnimation { duration: 250 } }

                FontButton {
                    id: copyButton
                    text: "\uf0c5"
                    onClicked: {
                        messageText.selectAll()
                        messageText.copy()
                        messageText.deselect()
                    }
                }

                FontButton {
                    id: playButton
                    visible: (item?.message?.role === OpenAIMessage.Assistant) && root.ttsEnabled
                    enabled: !root.ttsActive
                    text: "\uf04b"
                    onClicked: root.speak(messageText.getText(0, messageText.length))
                }

                FontButton {
                    id: deleteButton
                    text: "\uf1f8"
                    onClicked: {
                        root.model.removeMessage(item.message)
                    }
                }
            }
        }

        MouseArea {
            id: mouseArea
            anchors.fill: parent
            acceptedButtons: Qt.RightButton
            hoverEnabled: true
            onClicked: contextMenu.popup()
        }

        Menu {
            id: contextMenu

            MenuItem {
                text: qsTr("Copy Selection")
                onClicked: {
                    messageText.copy()
                }
            }

            MenuItem {
                text: qsTr("Copy All")
                onClicked: {
                    messageText.selectAll()
                    messageText.copy()
                    messageText.deselect()
                }
            }

            MenuSeparator {}

            RadioButton {
                id: markdownRadio
                text: qsTr("Render Markdown")
                checked: true
                onClicked: contextMenu.close()
            }

            RadioButton {
                id: htmlRadio
                text: qsTr("Render HTML")
                checked: false
                onClicked: contextMenu.close()
            }

            RadioButton {
                id: plainRadio
                text: qsTr("Render Plain Text")
                checked: false
                onClicked: contextMenu.close()
            }
        }
    }

    ColumnLayout {
        anchors.bottom: parent.bottom
        anchors.right: parent.right

        FontButton {
            id: addButton
            text: "\u002b"
            onClicked: {
                addMessageMenu.popup()
            }

            Menu {
                id: addMessageMenu
                MenuItem {
                    text: qsTr("User")
                    onClicked: {
                        root.model.addMessage(OpenAIMessage.User, "")
                    }
                }
                MenuItem {
                    text: qsTr("Assistant")
                    onClicked: {
                        root.model.addMessage(OpenAIMessage.Assistant, "")
                    }
                }
                MenuItem {
                    text: qsTr("System")
                    onClicked: {
                        root.model.addMessage(OpenAIMessage.System, "")
                    }
                }
            }
        }
    }

    // move to bottom
    onCountChanged: {
        if (count > 0) {
            root.positionViewAtEnd()
        }
    }

    add: Transition {
        NumberAnimation { properties: "opacity"; from: 0; to: 1.0; duration: 500 }
    }

    remove: Transition {
        NumberAnimation { properties: "opacity"; to: 0; duration: 500 }
    }

}
```

### `core/Style.qml`
```cpp
pragma Singleton
import QtQuick

QtObject {
    id: root

    readonly property real singleMargin: 5
    readonly property real doubleMargin: 10
    readonly property real spacing: 5
    readonly property string iconFont: "Font Awesome 6 Free"
}
```

### `live.qml`
```cpp
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import QtQuick.Window
import Qt.labs.settings
import com.machinekoder.live

ApplicationWindow {
  id: root
  visible: true
  title: qsTr("Intellicute Live Coding")
  width: 1024
  height: 800
  flags: liveCoding.flags
  visibility: liveCoding.visibility

  Component.onCompleted: {
      for (var i = 0; i < Qt.application.screens.length; ++i) {
          let screen = Qt.application.screens[i]
          if (screen.serialNumber === windowSettings.screen) {
              root.screen = screen
              return
          }
      }
  }

  Component.onDestruction: {
      windowSettings.screen = root.screen.serialNumber
  }

  LiveCodingPanel {
    id: liveCoding
    anchors.fill: parent
  }

  Settings {
    id: windowSettings
    category: "window"
    property alias width: root.width
    property alias height: root.height
    property alias x: root.x
    property alias y: root.y
    property alias visibility: liveCoding.visibility
    property alias flags: liveCoding.flags
    property alias hideToolBar: liveCoding.hideToolBar
    property string screen: ""
  }
}
```

### `main.qml`
```cpp
import QtQuick
import QtQuick.Controls

ApplicationWindow {
    width: 640
    height: 800
    visible: true
    title: qsTr("Intellicute")

    TopLevel {
        id: topLevel
        anchors.fill: parent
    }
}
```

### `RecordButton.qml`
```cpp
import QtQuick
import QtQuick.Controls
import Intellicute
import core

Button {
    id: control
    text: "\uf3c9"
    font.family: Style.iconFont
    font.pixelSize: 24
    enabled: whisperRequest.status !== WatsonTTSRequest.InProgress
    checkable: true

    QtObject {
        id: d
        property bool blinkActive: false
    }

    // blink timer
    Timer {
        id: blinkTimer
        interval: 500
        running: control.checked
        repeat: true
        onTriggered: {
            d.blinkActive = !d.blinkActive
        }
    }

    contentItem: Text {
        text: control.text
        font: control.font
        opacity: enabled ? 1.0 : 0.3
        color: control.checked ? (d.blinkActive ? "red" : "white") : "black"
        horizontalAlignment: Text.AlignHCenter
        verticalAlignment: Text.AlignVCenter
        elide: Text.ElideRight
    }
}```

### `SettingsPage.qml`
```cpp
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import Intellicute
import core

Page {
    id: root

    required property var settings

    signal cancel
    signal accept
    signal reset

    function applySettings() {
        root.settings.tts.autoplay = autoplayCheckbox.checked
        root.settings.tts.watson.use = useWatsonCheckbox.checked
        root.settings.tts.watson.voice = voiceComboBox.currentText
        root.settings.tts.locale = localeComboBox.currentText
        root.settings.tts.watson.apiKey = watsonApiKeyTextField.text
        root.settings.tts.watson.apiUrl = watsonApiUrlTextField.text
        root.settings.chat.defaultMessages = JSON.parse(messageModel.jsonString)
        root.settings.chat.temperature = temperatureSlider.value
        root.settings.chat.topP = topPSlider.value
        root.settings.chat.frequencyPenalty = frequencyPenaltySlider.value
        root.settings.chat.presencePenalty = presencePenaltySlider.value
        root.settings.chat.maxTokens = maxTokensSpinBox.value
        root.settings.openai.accessToken = openAiAccessTokenTextField.text
    }

    QtObject {
        id: d
        readonly property var watsonVoices: ["de-DE_DieterV3Voice", "de-DE_BirgitV3Voice", "en-US_AllisonV3Voice", "en-US_LisaV3Voice", "en-US_MichaelV3Voice", "es-ES_EnriqueV3Voice", "es-ES_LauraV3Voice", "es-LA_SofiaV3Voice", "es-US_SofiaV3Voice", "fr-FR_ReneeV3Voice", "it-IT_FrancescaV3Voice", "ja-JP_EmiV3Voice", "ko-KR_YoungmiV3Voice", "pt-BR_IsabelaV3Voice", "zh-CN_LiNaVoice", "zh-CN_WangWeiVoice", "zh-CN_ZhangJingVoice"]
        readonly property var openAiModels: ["gpt-3.5-turbo"]
    }

    component ValueSlider: RowLayout {
        property alias value: control.value
        property alias slider: control

        Label {
            text: control.from
        }

        Slider {
            id: control
            Layout.fillWidth: true
            from: 0
            to: 1
            stepSize: 0.1
            handle: Rectangle {
                x: control.leftPadding + control.visualPosition * (control.availableWidth - width)
                y: control.topPadding + control.availableHeight / 2 - height / 2
                implicitWidth: 32
                implicitHeight: 32
                radius: width / 2.0
                color: control.pressed ? "#f0f0f0" : "#f6f6f6"
                border.color: "#bdbebf"

                Label {
                    anchors.centerIn: parent
                    text: control.value.toFixed(1)
                }
            }
        }

        Label {
            text: control.to
        }
    }

    component HidableTextField: RowLayout {
        property alias text: control.text
        property alias textField: control
        property alias hidden: button.checked

        TextField {
            id: control
            Layout.fillWidth: true
            echoMode: !button.checked ? TextInput.Password : TextInput.Normal
        }

        ToolButton {
            id: button
            text: control.echoMode == TextInput.Normal ? "\uf070" : "\uf06e"
            font.family: "FontAwesome"
            checkable: true
        }
    }

    ColumnLayout {
        anchors.fill: parent
        anchors.margins: Style.singleMargin

        ScrollView {
            id: scrollView
            readonly property bool scrollBarRequired: scrollView.contentHeight
                                                      > scrollView.availableHeight
            contentWidth: availableWidth
            Layout.fillWidth: true
            Layout.fillHeight: true
            ScrollBar.vertical.policy: scrollBarRequired ? ScrollBar.AlwaysOn : ScrollBar.AlwaysOff

            ColumnLayout {
                id: settingsContent
                width: scrollView.availableWidth
                       - (scrollView.scrollBarRequired ? scrollView.ScrollBar.vertical.width
                                                         + Style.singleMargin : 0)
                height: implicitHeight > scrollView.availableHeight ? implicitHeight : scrollView.availableHeight

                ColumnLayout {
                    Layout.fillWidth: true
                    Layout.fillHeight: true

                    GroupBox {
                        Layout.fillWidth: true
                        Layout.fillHeight: true
                        Layout.preferredHeight: 300
                        title: qsTr("Default Messages")
                        clip: true

                        ChatView {
                            anchors.fill: parent
                            anchors.margins: Style.singleMargin
                            model: OpenAIMessageModel {
                                id: messageModel
                                jsonString: JSON.stringify(
                                                root.settings.chat.defaultMessages)
                            }
                        }
                    }

                    GroupBox {
                        Layout.fillWidth: true
                        title: qsTr("Chat Settings")

                        GridLayout {
                            anchors.fill: parent
                            columns: 2

                            Label {
                                text: qsTr("Temperature")
                            }

                            ValueSlider {
                                id: temperatureSlider
                                Layout.fillWidth: true
                                slider.value: root.settings.chat.temperature
                            }

                            Label {
                                text: qsTr("Top P")
                            }

                            ValueSlider {
                                id: topPSlider
                                Layout.fillWidth: true
                                slider.value: root.settings.chat.topP
                            }

                            Label {
                                text: qsTr("Frequency Penalty")
                            }

                            ValueSlider {
                                id: frequencyPenaltySlider
                                Layout.fillWidth: true
                                slider.value: root.settings.chat.frequencyPenalty
                            }

                            Label {
                                text: qsTr("Presence Penalty")
                            }

                            ValueSlider {
                                id: presencePenaltySlider
                                Layout.fillWidth: true
                                slider.value: root.settings.chat.presencePenalty
                            }

                            Label {
                                text: qsTr("Max Tokens")
                            }

                            SpinBox {
                                id: maxTokensSpinBox
                                value: root.settings.chat.maxTokens
                                from: 1
                                to: 2048
                                editable: true
                            }

                            Label {
                                text: qsTr("OpenAI API Access Token")
                            }

                            HidableTextField {
                                id: openAiAccessTokenTextField
                                Layout.fillWidth: true
                                text: root.settings.openai.accessToken
                            }
                        }
                    }

                    GroupBox {
                        Layout.fillWidth: true
                        title: qsTr("TTS Settings")

                        GridLayout {
                            anchors.fill: parent
                            columns: 2

                            CheckBox {
                                id: autoplayCheckbox
                                Layout.columnSpan: 2
                                text: qsTr("Auto Speak")
                                checked: root.settings.tts.autoplay
                            }

                            Label {
                                text: qsTr("TTS Locale")
                            }

                            ComboBox {
                                id: localeComboBox
                                model: ["de", "en", "es", "fr", "it", "ja", "ko", "pt", "zh"]
                                currentIndex: model.indexOf(
                                                  root.settings.tts.locale)
                            }

                            GroupBox {
                                label: CheckBox {
                                    id: useWatsonCheckbox
                                    text: qsTr("Use Watson TTS")
                                    checked: root.settings.tts.watson.use
                                }
                                Layout.columnSpan: 2
                                Layout.fillWidth: true

                                GridLayout {
                                    anchors.fill: parent
                                    enabled: useWatsonCheckbox.checked
                                    columns: 2

                                    Label {
                                        text: qsTr("Voice")
                                    }

                                    ComboBox {
                                        id: voiceComboBox
                                        Layout.fillWidth: true
                                        model: d.watsonVoices
                                        currentIndex: d.watsonVoices.indexOf(
                                                          root.settings.tts.watson.voice)
                                    }

                                    Label {
                                        text: qsTr("IBM Watson API Key")
                                    }

                                    HidableTextField {
                                        id: watsonApiKeyTextField
                                        Layout.fillWidth: true
                                        text: root.settings.tts.watson.apiKey
                                    }

                                    Label {
                                        text: qsTr("IBM Watson API URL")
                                    }

                                    HidableTextField {
                                        id: watsonApiUrlTextField
                                        Layout.fillWidth: true
                                        text: root.settings.tts.watson.apiUrl
                                    }
                                }
                            }
                        }
                    }
                }

                Item {
                    Layout.fillHeight: true
                }
            }
        }

        RowLayout {

            Button {
                id: rejectButton
                text: qsTr("Cancel")
                onClicked: {
                    root.cancel()
                }
            }

            Button {
                id: resetButton
                text: qsTr("Reset to Defaults")
                onClicked: {
                    root.reset()
                }
            }

            Item {
                Layout.fillWidth: true
            }

            Button {
                id: closeButton
                text: qsTr("Apply")
                onClicked: {
                    root.applySettings()
                    root.accept()
                }
            }
        }
    }
}
```

### `TopLevel.qml`
```cpp
import QtQuick
import QtQuick.Controls
import QtQuick.Layouts
import Qt.labs.settings

Item {
    id: root

    property var settings: defaultSettings
    readonly property var defaultSettings: {
        "tts": {
            "autoplay": false,
            "locale": "en",
            "watson": {
                "use": false,
                "voice": "en-US_MichaelV3Voice",
                "apiKey": "",
                "apiUrl": ""
            }
        },
        "chat": {
            "defaultMessages": {
                "messages": [
                    {"role": "system", "content": "Act as friendly and intelligent AI assistant. Your name is 'Intellicute'. Your UI is written with Qt and QML by [Machine Koder](https://machinekoder.com)."}
                ]},
            "model": "gpt-3.5-turbo",
            "maxTokens": 2048,
            "temperature": 0.3,
            "topP": 1.0,
            "frequencyPenalty": 0.0,
            "presencePenalty": 0.0,
        },
        "openai": {
            "accessToken": ""
        }
    }

    function resetSettings() {
        root.settings = root.defaultSettings
    }

    Settings {
        id: settingsStore
        property alias settings: root.settings
    }


    StackView {
        id: stack
        anchors.fill: parent
    }

    Component {
        id: chatPage
        ChatPage {
            settings: root.settings
            onSettingsRequested: stack.push(settingsPage)
        }
    }

    Component {
        id: settingsPage
        SettingsPage {
            settings: root.settings
            onCancel: stack.pop()
            onReset: root.resetSettings()
            onAccept: {
                root.settings = settings
                stack.pop()
            }
        }
    }

    Component.onCompleted: {
        stack.push(chatPage)
    }
}
```

### `qml.qrc`
```cpp
<RCC>
    <qresource prefix="/">
        <file>core/qmldir</file>
        <file>core/Style.qml</file>
        <file>TopLevel.qml</file>
        <file>SettingsPage.qml</file>
        <file>RecordButton.qml</file>
        <file>ChatView.qml</file>
        <file>ChatPage.qml</file>
        <file>main.qml</file>
        <file>live.qml</file>
    </qresource>
</RCC>
```

### `resources.qrc`
```cpp
<RCC>
    <qresource prefix="/">
        <file>qtquickcontrols2.conf</file>
        <file>fonts/fa-solid-900.ttf</file>
        <file>icons/intellicute_32.png</file>
        <file>icons/intellicute_64.png</file>
        <file>icons/intellicute_128.png</file>
        <file>icons/intellicute_256.png</file>
        <file>icons/intellicute_512.png</file>
        <file>icons/intellicute_512.svg</file>
    </qresource>
</RCC>
```

I'd like you to give me a plan for creating a new Qt program which directly uses as many source files, or code blocks from this as necessary, while also beginning on providing the architecture and user interface necessary for the workflow as I've described it.

Here is what the initial, boilerplate program we will begin development out of looks like:


Directory Tree:
VibeKoder
├── CMakeLists.txt
├── main.cpp
├── mainwindow.cpp
├── mainwindow.h
└── mainwindow.ui

1 directory, 5 files

### `CMakeLists.txt`
```cpp
cmake_minimum_required(VERSION 3.16)

project(VibeKoder VERSION 0.1 LANGUAGES CXX)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Widgets)

set(PROJECT_SOURCES
        main.cpp
        mainwindow.cpp
        mainwindow.h
        mainwindow.ui
)

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(VibeKoder
        MANUAL_FINALIZATION
        ${PROJECT_SOURCES}
    )
# Define target properties for Android with Qt 6 as:
#    set_property(TARGET VibeKoder APPEND PROPERTY QT_ANDROID_PACKAGE_SOURCE_DIR
#                 ${CMAKE_CURRENT_SOURCE_DIR}/android)
# For more information, see https://doc.qt.io/qt-6/qt-add-executable.html#target-creation
else()
    if(ANDROID)
        add_library(VibeKoder SHARED
            ${PROJECT_SOURCES}
        )
# Define properties for Android with Qt 5 after find_package() calls as:
#    set(ANDROID_PACKAGE_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/android")
    else()
        add_executable(VibeKoder
            ${PROJECT_SOURCES}
        )
    endif()
endif()

target_link_libraries(VibeKoder PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)

# Qt for iOS sets MACOSX_BUNDLE_GUI_IDENTIFIER automatically since Qt 6.1.
# If you are developing for iOS or macOS you should consider setting an
# explicit, fixed bundle identifier manually though.
if(${QT_VERSION} VERSION_LESS 6.1.0)
  set(BUNDLE_ID_OPTION MACOSX_BUNDLE_GUI_IDENTIFIER com.example.VibeKoder)
endif()
set_target_properties(VibeKoder PROPERTIES
    ${BUNDLE_ID_OPTION}
    MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
    MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
    MACOSX_BUNDLE TRUE
    WIN32_EXECUTABLE TRUE
)

include(GNUInstallDirs)
install(TARGETS VibeKoder
    BUNDLE DESTINATION .
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

if(QT_VERSION_MAJOR EQUAL 6)
    qt_finalize_executable(VibeKoder)
endif()
```

### `mainwindow.h`
```cpp
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>

QT_BEGIN_NAMESPACE
namespace Ui {
class MainWindow;
}
QT_END_NAMESPACE

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private:
    Ui::MainWindow *ui;
};
#endif // MAINWINDOW_H
```

### `main.cpp`
```cpp
#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
```

### `mainwindow.cpp`
```cpp
#include "mainwindow.h"
#include "./ui_mainwindow.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}
```

### `mainwindow.ui`
```cpp
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>MainWindow</string>
  </property>
  <widget class="QWidget" name="centralwidget"/>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>800</width>
     <height>23</height>
    </rect>
   </property>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
 </widget>
 <resources/>
 <connections/>
</ui>
```

I'd like your proposal of necessary classes, workflows, and plans for integration of the re-usable parts of the chat client source code. Please be high level and verbose, I am happy to spend the tokens. Ask any questions necessary. I know we will need a markdown parser for reading the source and development docs and for creating the prompt stack; I know we will need some sort of code parser for high-lighting.

What is the plan for building this thing quickly and efficiently? 

-----------


Right now, what I really needs is just a bare-basic program for persisting prompt-stacks locally on my computer, i.e. saving conversations I have with the LLM via the interface, to get out of using the stupid playground.


